{"meta":{"title":"wangxt的博客","subtitle":"wangxt的个人博客站点","description":"wangxt的个人博客站点","author":"wangxt","url":"http://blog.wangxt.online","root":"/"},"pages":[{"title":"","date":"2022-11-27T17:13:47.801Z","updated":"2022-11-27T17:13:47.801Z","comments":true,"path":"about/index.html","permalink":"http://blog.wangxt.online/about/index.html","excerpt":"","text":""},{"title":"blogger","date":"2022-11-27T14:29:46.000Z","updated":"2022-11-27T14:29:46.656Z","comments":true,"path":"blogger/index.html","permalink":"http://blog.wangxt.online/blogger/index.html","excerpt":"","text":""},{"title":"donate","date":"2022-11-27T14:29:56.000Z","updated":"2022-11-27T14:29:56.894Z","comments":true,"path":"donate/index.html","permalink":"http://blog.wangxt.online/donate/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-11-27T17:13:52.532Z","updated":"2022-11-27T17:13:52.532Z","comments":true,"path":"category/index.html","permalink":"http://blog.wangxt.online/category/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-27T17:13:57.651Z","updated":"2022-11-27T17:13:57.651Z","comments":true,"path":"friends/index.html","permalink":"http://blog.wangxt.online/friends/index.html","excerpt":"O(∩_∩)O","text":"O(∩_∩)O 暂无"},{"title":"标签","date":"2022-11-27T17:13:55.171Z","updated":"2022-11-27T17:13:55.171Z","comments":true,"path":"tag/index.html","permalink":"http://blog.wangxt.online/tag/index.html","excerpt":"","text":""},{"title":"tagcloud","date":"2022-11-27T14:29:51.000Z","updated":"2022-11-27T14:29:51.851Z","comments":true,"path":"tagcloud/index.html","permalink":"http://blog.wangxt.online/tagcloud/index.html","excerpt":"","text":""}],"posts":[{"title":"Maven引入外部jar包的方式","slug":"2020-09-15-maven引入外部jar包的方式","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:12:53.030Z","comments":true,"path":"2022/12/04/2020-09-15-maven引入外部jar包的方式/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/2020-09-15-maven%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8jar%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"当我们遇到没有上传到maven仓库中但又需要导入本地项目使用的jar包时，可以参考maven引入外部jar包的方式，在本地开发环境直接引入相关的jar包进行使用，不过部署到生产项目时，不要忘记同时推到私仓里。","text":"当我们遇到没有上传到maven仓库中但又需要导入本地项目使用的jar包时，可以参考maven引入外部jar包的方式，在本地开发环境直接引入相关的jar包进行使用，不过部署到生产项目时，不要忘记同时推到私仓里。 一、dependency 本地jar包1234567&lt;dependency&gt; &lt;groupId&gt;com.dataozi&lt;/groupId&gt; &lt;!--自定义--&gt; &lt;artifactId&gt;sdk&lt;/artifactId&gt; &lt;!--自定义--&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!--自定义--&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!--system，类似provided，需要显式提供依赖的jar以后，Maven就不会在Repository中查找它--&gt; &lt;systemPath&gt;$&#123;libpath&#125;/lib/sdk-1.0.0.jar&lt;/systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt;&lt;/dependency&gt; 二、编译阶段指定外部lib123456789101112&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;lib&lt;/extdirs&gt;&lt;!--指定外部lib--&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; 三、将外部jar打入本地maven仓库(推荐)使用maven命令在指定maven仓库路径打好jar包 1mvn install:install-file -Dfile=$&#123;jar包路径&#125; -DgroupId=$&#123;groupId&#125; -DartifactId=$&#123;artifactId&#125; -Dversion=$&#123;指定版本&#125; -Dpackaging=$&#123;指定打包方式&#125; 1mvn install:install-file -Dfile=test.jar -DgroupId=com.dataozi -DartifactId=sdk -Dversion=1.0.0 -Dpackaging=jar 在项目中直接引入jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.dataozi&lt;/groupId&gt; &lt;artifactId&gt;sdk&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://blog.wangxt.online/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://blog.wangxt.online/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"Arrays$asList()抛UnsupportedOperationException异常","slug":"Arrays$asList()抛UnsupportedOperationException异常","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:06:04.970Z","comments":true,"path":"2022/12/04/Arrays$asList()抛UnsupportedOperationException异常/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/Arrays$asList()%E6%8A%9BUnsupportedOperationException%E5%BC%82%E5%B8%B8/","excerpt":"今天写代码时遇到一个很奇怪的问题，我很主观的利用Arrays.asList()方法返回一个List，然后对该List进行了add()方法的调用，结果竟然抛了异常。将问题原因记录一下。","text":"今天写代码时遇到一个很奇怪的问题，我很主观的利用Arrays.asList()方法返回一个List，然后对该List进行了add()方法的调用，结果竟然抛了异常。将问题原因记录一下。 示例代码： 1234567@org.junit.Testpublic void test()&#123; List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;); boolean cc = list.add(&quot;cc&quot;); System.out.println(list);&#125; 报错如下： 1234567891011121314151617181920212223242526java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) at com.chuangkit.design.center.assist.impl.Test.test(Test.java:19) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:221) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) 1.接下来我们看下源码，排查异常产生的原因我们点进asList()方法看下源码是怎么实现的。 12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 这里发现这不是返回的就是一个new出来的ArrayList集合对象吗，没有什么问题啊，别着急，我们在进到ArrayList看看猫腻。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return a.clone(); &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; &#125; 这时我们发现，此ArrayList并不是我们常用的java.util包下的，而是Arrays类自己实现的一个静态内部类，该内部类继承了AbstractList抽象类，我们知道AbstractList是实现了List接口的，而AbstractList本身也是一个抽象类，并没有对add等方法进行实现，Arrays$ArrayList虽然继承了AbstractList，但是也没有对add等方法进行实现，所以当我们调用该内部类的add方法时就抛出UnsupportedOperationException异常。 123456789101112131415161718192021// 1.首先我们看ArrayList继承了AbstractListprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123;// 2.然后AbstractList又实现了List接口public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;// 3.在List的add方法注释上可以看到如果实现类没有实现add方法就会抛异常/** * ... * @throws UnsupportedOperationException if the &#123;@code add&#125; operation * is not supported by this list * ... */public boolean add(E e) &#123; add(size(), e); return true;&#125; 2.问题我们找到了，接下来我们想一想为什么Arrays要自己实现一个ArrayList呢我们先看下源码注释是怎么说的（摘自于asList方法注释） 123456789101112131415161718/** * Returns a fixed-size list backed by the specified array. (Changes to * the returned list &quot;write through&quot; to the array.) This method acts * as bridge between array-based and collection-based APIs, in * combination with &#123;@link Collection#toArray&#125;. The returned list is * serializable and implements &#123;@link RandomAccess&#125;. * * &lt;p&gt;This method also provides a convenient way to create a fixed-size * list initialized to contain several elements: * ... * 返回由指定数组支持的固定大小列表。（更改返回的列表“直写”到数组。） * 此方法与 &#123;@link Collection#toArray&#125; 结合，充当基于数组和基于集合的 API 之间的桥梁。 * 返回的列表是可序列化的并实现了 &#123;@link RandomAccess&#125;。此方法还提供了一种创建固定大小列表 * 的便捷方法，该列表已初始化为包含多个元素。 * ... * @return a list view of the specified array * 指定数组的列表视图 */ asList方法返回的是当前数组的的列表视图，当我们改变原始数组的数据时，这个”视图”会自然而然的同步改变，因为它就是当前数组的一个展现形式，如果返回的是java.util包下的ArrayList，无疑会创建一个新的数组来代替当前数组，并且我们新的数据进行修改，原数组的数据也不会发生改变。 asList方法返回的是一个固定大小列表，也就是说只要数组创建了，我们无法向数组中添加新的元素，只能对现有元素进行替换和查找，并且不能删除元素。这个java.util包下的ArrayList也是无法做到的。 此方法充当基于数组的API和基于集合的API之间的桥梁，这句话也体现了，asList方法本身就不是一个真正意义上的集合方法，只是在基于两者的API基础上做了一个衔接。 3.总结Arrays$asList()本身并没有创建和返回一个新的集合对象，返回的仍然是描述原数组的视图，也就是该”集合”只满足对数组的操作，一但声明集合大小不能修改、不能直接删除某个元素等等；也就是说当我们通过asList方法将数组转成集合之后，我们对该集合的操作仅仅满足于对一个数组的操作，那么我们是可以使用这个方法的，如果想要得到的集合满足于一个真实集合对象的使用，那么这个方法是不适用的，我们这时候需要将数组复制到一个新的数组支持集合的创建，比如 123456789@org.junit.Testpublic void test()&#123; List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;); List&lt;String&gt; temp = new ArrayList&lt;&gt;(list); temp.add(&quot;cc&quot;); System.out.println(temp);&#125;","categories":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"Arrays","slug":"Arrays","permalink":"http://blog.wangxt.online/tags/Arrays/"},{"name":"视图","slug":"视图","permalink":"http://blog.wangxt.online/tags/%E8%A7%86%E5%9B%BE/"},{"name":"踩坑","slug":"踩坑","permalink":"http://blog.wangxt.online/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"InnoDB几个索引数据结构的区别","slug":"InnoDB几个索引数据结构的区别","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:08:32.216Z","comments":true,"path":"2022/12/04/InnoDB几个索引数据结构的区别/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/InnoDB%E5%87%A0%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"我们知道，MySQL中InnoDB执行引擎的索引实现底层数据结构是B+树，为什么选择B+树，而不选择其它数据，如Hash,二叉树等，我们今天探讨下这个问题","text":"我们知道，MySQL中InnoDB执行引擎的索引实现底层数据结构是B+树，为什么选择B+树，而不选择其它数据，如Hash,二叉树等，我们今天探讨下这个问题 索引的本质索引是帮助Mysql高效获取数据的==排好序==的==数据结构== 索引数据结构假如有如上一张表，如果想要查询col2=23的那行数据，如果没有索引或者不走索引的话，那么将要查询7次才会查询到，并且这7行数据在磁盘里并不是挨着存储的，查询效率会非常低。 二叉树 如上图，我们可以考虑将col2列放在一个二叉树的数据结构中，同样还是查询col2=23的记录，则只需要查询3次就可以查询到，效率要比没有索引的高得多。 但是二叉树也有弊端，如col1，如果我们把一个按照大小顺序排序的列数据存入二叉树中，我们发现，最终其实会以类似链表的形式进行存储，我们在查询col1=7发现还是需要查询7次，所以对于这种有序的数据，并没有有效的提高查询效率。 红黑树 红黑树是一种二叉平衡树，可以保证单边叶子节点不超过3，如果超过则会进行自平衡，如图，可以发现它避免了二叉树的弊端。 但是使用红黑树的话，无法保证树的高度，假如我们表中对应索引行有1000万条数据，那么索引树会有1000万个节点，那么树的高度就是2的n次方=10000万，树的高度会很高，查询效率仍然会受到限制；另外，对于红黑树，每次单边超过3时，都会自平衡，需要成本较高的维护。 Hash表特点：对索引的key进行一次hash计算就可以定位出数据存储的位置 很多时候Hash索引要比B+ 树索引更高效 仅能满足 “=”，“IN”，不支持范围查询 hash冲突问题 B-TreeB-Tree实际上解决了红黑树高度不可控的问题，B-Tree以数据页的方式存储数据，对于红黑树每个节点只能存储一个索引数据，B-Tree可以存储一页索引数据，每个数据页又可以分叉成n个数据页，这样，每个节点存储的索引数据多了，树的高度就降低了。 特点：B-Tree 叶节点具有相同的深度，叶节点的指针为空 所有索引元素不重复 节点中的数据索引从左到右递增排列。 B+Tree特点：非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引 叶子节点包含所有索引字段 叶子节点用指针连接，提高区间访问的性能","categories":[{"name":"思考总结","slug":"思考总结","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"},{"name":"Mysql","slug":"思考总结/Mysql","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/Mysql/"}],"tags":[{"name":"InnoDB索引","slug":"InnoDB索引","permalink":"http://blog.wangxt.online/tags/InnoDB%E7%B4%A2%E5%BC%95/"},{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wangxt.online/tags/Mysql/"},{"name":"数据结构","slug":"数据结构","permalink":"http://blog.wangxt.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Cent os 安装jdk","slug":"Centos安装jdk","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:07:19.363Z","comments":true,"path":"2022/12/04/Centos安装jdk/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/Centos%E5%AE%89%E8%A3%85jdk/","excerpt":"整理一下cent os安装jdk的方式","text":"整理一下cent os安装jdk的方式 手动安装创建安装目录123[root@iZ8vb7tm9o88h6ioml28vsZ usr]# cd /usr[root@iZ8vb7tm9o88h6ioml28vsZ usr]# mkdir java[root@iZ8vb7tm9o88h6ioml28vsZ usr]# cd java 下载jdk 源码包 Oracle 官网地址 下载之后上传到服务器 如果感觉麻烦的话，也可以使用wget 直接使用下载链接获取到的tar包是有问题的，oracle对链接进行了授权校验：wget https://download.oracle.com/otn/java/jdk/8u291-b10/d7fc238d0cbf4b0dac67be84580cfb4b/jdk-8u291-linux-x64.tar.gz 我们需要在下载链接之前加上 –no-cookies –no-check-certificate –header “Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F;oraclelicense=accept-securebackup-cookie” ，如: 1wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;https://download.oracle.com/otn/java/jdk/8u291-b10/d7fc238d0cbf4b0dac67be84580cfb4b/jdk-8u291-linux-x64.tar.gz&quot; 解压123456789# 解压包[root@iZ8vb7tm9o88h6ioml28vsZ java]# tar -zxvf jdk-8u141-linux-x64.tar.gz# 解压完之后会生成一个 jdk1.8.0_141 的文件夹[root@iZ8vb7tm9o88h6ioml28vsZ java]# lsjdk1.8.0_141 jdk-8u141-linux-x64.tar.gz[root@iZ8vb7tm9o88h6ioml28vsZ java]# cd jdk1.8.0_141/# 获取当前文件夹得绝对路径，配置环境变量时会用[root@iZ8vb7tm9o88h6ioml28vsZ jdk1.8.0_141]# pwd/usr/java/java/jdk1.8.0_141 配置环境变量1234567vim /etc/profile在文件最后加上# javaexport JAVA_HOME=/usr/java/java/jdk1.8.0_141 #上步 pwd 命令获取到的路径export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib 验证1234567# 使 profile 修改生效[root@iZ8vb7tm9o88h6ioml28vsZ java]# source /etc/profile# 验证结果[root@iZ8vb7tm9o88h6ioml28vsZ java]# java -versionjava version &quot;1.8.0_291&quot;Java(TM) SE Runtime Environment (build 1.8.0_291-b10)Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode) yum安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 搜索可用的jdk安装包[root@iZ8vb7tm9o88h6ioml28vsZ java]# yum search java|grep jdkldapjdk-javadoc.noarch : Javadoc for ldapjdkjava-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.6.0-openjdk-demo.x86_64 : OpenJDK Demosjava-1.6.0-openjdk-devel.x86_64 : OpenJDK Development Environmentjava-1.6.0-openjdk-javadoc.x86_64 : OpenJDK API Documentationjava-1.6.0-openjdk-src.x86_64 : OpenJDK Source Bundlejava-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.7.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connectorjava-1.7.0-openjdk-demo.x86_64 : OpenJDK Demosjava-1.7.0-openjdk-devel.x86_64 : OpenJDK Development Environmentjava-1.7.0-openjdk-headless.x86_64 : The OpenJDK runtime environment withoutjava-1.7.0-openjdk-javadoc.noarch : OpenJDK API Documentationjava-1.7.0-openjdk-src.x86_64 : OpenJDK Source Bundlejava-1.8.0-openjdk.i686 : OpenJDK Runtime Environment 8java-1.8.0-openjdk.x86_64 : OpenJDK 8 Runtime Environmentjava-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connectorjava-1.8.0-openjdk-demo.i686 : OpenJDK Demos 8java-1.8.0-openjdk-demo.x86_64 : OpenJDK 8 Demosjava-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment 8java-1.8.0-openjdk-devel.x86_64 : OpenJDK 8 Development Environmentjava-1.8.0-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 8java-1.8.0-openjdk-headless.x86_64 : OpenJDK 8 Headless Runtime Environmentjava-1.8.0-openjdk-javadoc.noarch : OpenJDK 8 API documentationjava-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK 8 API documentation compressedjava-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle 8java-1.8.0-openjdk-src.x86_64 : OpenJDK 8 Source Bundlejava-11-openjdk.i686 : OpenJDK Runtime Environment 11java-11-openjdk.x86_64 : OpenJDK 11 Runtime Environmentjava-11-openjdk-demo.i686 : OpenJDK Demos 11java-11-openjdk-demo.x86_64 : OpenJDK 11 Demosjava-11-openjdk-devel.i686 : OpenJDK Development Environment 11java-11-openjdk-devel.x86_64 : OpenJDK 11 Development Environmentjava-11-openjdk-headless.i686 : OpenJDK Headless Runtime Environment 11java-11-openjdk-headless.x86_64 : OpenJDK 11 Headless Runtime Environmentjava-11-openjdk-javadoc.i686 : OpenJDK 11 API documentationjava-11-openjdk-javadoc.x86_64 : OpenJDK 11 API documentationjava-11-openjdk-javadoc-zip.i686 : OpenJDK 11 API documentation compressed in ajava-11-openjdk-javadoc-zip.x86_64 : OpenJDK 11 API documentation compressed injava-11-openjdk-jmods.i686 : JMods for OpenJDK 11java-11-openjdk-jmods.x86_64 : JMods for OpenJDK 11java-11-openjdk-src.i686 : OpenJDK Source Bundle 11java-11-openjdk-src.x86_64 : OpenJDK 11 Source Bundlejava-11-openjdk-static-libs.i686 : OpenJDK libraries for static linking 11java-11-openjdk-static-libs.x86_64 : OpenJDK 11 libraries for static linkingjava-latest-openjdk.x86_64 : OpenJDK 16 Runtime Environmentjava-latest-openjdk-debug.x86_64 : OpenJDK 16 Runtime Environment with fulljava-latest-openjdk-demo.x86_64 : OpenJDK 16 Demosjava-latest-openjdk-demo-debug.x86_64 : OpenJDK 16 Demos with full debugging onjava-latest-openjdk-demo-fastdebug.x86_64 : OpenJDK 16 Demos with minimaljava-latest-openjdk-devel.x86_64 : OpenJDK 16 Development Environmentjava-latest-openjdk-devel-debug.x86_64 : OpenJDK 16 Development Environment withjava-latest-openjdk-devel-fastdebug.x86_64 : OpenJDK 16 Development Environmentjava-latest-openjdk-fastdebug.x86_64 : OpenJDK 16 Runtime Environment withjava-latest-openjdk-headless.x86_64 : OpenJDK 16 Headless Runtime Environmentjava-latest-openjdk-headless-debug.x86_64 : OpenJDK 16 Runtime Environment withjava-latest-openjdk-headless-fastdebug.x86_64 : OpenJDK 16 Runtime Environmentjava-latest-openjdk-javadoc.x86_64 : OpenJDK 16 API documentationjava-latest-openjdk-javadoc-zip.x86_64 : OpenJDK 16 API documentation compressedjava-latest-openjdk-jmods.x86_64 : JMods for OpenJDK 16java-latest-openjdk-jmods-debug.x86_64 : JMods for OpenJDK 16 with fulljava-latest-openjdk-jmods-fastdebug.x86_64 : JMods for OpenJDK 16 with minimaljava-latest-openjdk-src.x86_64 : OpenJDK 16 Source Bundlejava-latest-openjdk-src-debug.x86_64 : OpenJDK 16 Source Bundle for packagesjava-latest-openjdk-src-fastdebug.x86_64 : OpenJDK 16 Source Bundlejava-latest-openjdk-static-libs.x86_64 : OpenJDK 16 libraries for static linkingjava-latest-openjdk-static-libs-debug.x86_64 : OpenJDK 16 libraries for staticjava-latest-openjdk-static-libs-fastdebug.x86_64 : OpenJDK 16 libraries forldapjdk.noarch : The Mozilla LDAP Java SDK# 安装[root@iZ8vb7tm9o88h6ioml28vsZ java]# yum install java-1.8.0-openjdk# 默认安装在 /usr/lib/jvm 下[root@iZ8vb7tm9o88h6ioml28vsZ jvm]# cd /usr/lib/jvm/[root@iZ8vb7tm9o88h6ioml28vsZ jvm]# ls -ltotal 4drwxr-xr-x 3 root root 4096 Jun 20 18:33 java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64lrwxrwxrwx 1 root root 21 Jun 20 18:33 jre -&gt; /etc/alternatives/jrelrwxrwxrwx 1 root root 27 Jun 20 18:33 jre-1.8.0 -&gt; /etc/alternatives/jre_1.8.0lrwxrwxrwx 1 root root 35 Jun 20 18:33 jre-1.8.0-openjdk -&gt; /etc/alternatives/jre_1.8.0_openjdklrwxrwxrwx 1 root root 51 Jun 20 18:33 jre-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64 -&gt; java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/jrelrwxrwxrwx 1 root root 29 Jun 20 18:33 jre-openjdk -&gt; /etc/alternatives/jre_openjdk 安装完之后同样配置环境变量，验证结果。","categories":[{"name":"运维技巧","slug":"运维技巧","permalink":"http://blog.wangxt.online/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"jdk按照","slug":"jdk按照","permalink":"http://blog.wangxt.online/tags/jdk%E6%8C%89%E7%85%A7/"},{"name":"centos","slug":"centos","permalink":"http://blog.wangxt.online/tags/centos/"}]},{"title":"SpringBoot整合Swagger(spring-boot-starter-swagger)","slug":"SpringBoot整合Swagger(spring-boot-starter-swagger)","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:12:10.236Z","comments":true,"path":"2022/12/04/SpringBoot整合Swagger(spring-boot-starter-swagger)/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/SpringBoot%E6%95%B4%E5%90%88Swagger(spring-boot-starter-swagger)/","excerpt":"我们在使用swagger时，需要配置config配置类，spring-boot-starter-swagger则利用Spring Boot的自动化配置特性来实现快速的将swagger2引入spring boot应用来生成API文档，简化原生使用swagger2的整合代码。","text":"我们在使用swagger时，需要配置config配置类，spring-boot-starter-swagger则利用Spring Boot的自动化配置特性来实现快速的将swagger2引入spring boot应用来生成API文档，简化原生使用swagger2的整合代码。 GitHub地址 一、引入pom12345&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.9.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 二、项目启动类添加 @EnableSwagger2Doc123456789@EnableSwagger2Doc@SpringBootApplicationpublic class SpringbootSwaggerSpring4allApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootSwaggerSpring4allApplication.class, args); &#125;&#125; 三、在项目配置文件中配置参数123456789101112131415161718# 是否启用swagger，默认：trueswagger.enabled=true# 需要处理的基础URL规则，默认：/**swagger.base-path=/**# 扫描的基础包，默认：全扫描swagger.base-package=com.wangxt.springbootswaggerspring4all.controller# 标题swagger.title=springboot-swagger-spring4all# 描述swagger.description=swagger-spring4all-demo# 版本swagger.version=2.9.2# 维护人swagger.contact.name=wangxt# 维护人URLswagger.contact.url=https://wangxt.online# 维护人emailswagger.contact.email=1471520488@qq.com 四、写个接口看看效果Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.wangxt.springbootswaggerspring4all.controller;import com.wangxt.springbootswaggerspring4all.domain.po.DemoPo;import com.wangxt.springbootswaggerspring4all.domain.response.ResponseInfo;import com.wangxt.springbootswaggerspring4all.domain.vo.DemoVo;import com.wangxt.springbootswaggerspring4all.service.DemoService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * * 示例 controller * @author wangxt * @date 2021/7/30 10:11 */@Api(tags = &quot;示例 controller&quot;)@RestController@RequestMapping(&quot;/demo/&quot;)public class DemoController &#123; @Autowired private DemoService demoService; /** * * 参数为普通参数示例方法 * @author wangxt * @date 2021/7/30 10:53 * @return ResponseInfo */ @ApiOperation(value = &quot;参数为普通参数示例方法&quot;) @GetMapping(&quot;demo&quot;) public ResponseInfo&lt;DemoVo&gt; demo(@ApiParam(name = &quot;用户ID&quot;, required = true, example = &quot;1&quot;) Integer userId)&#123; return demoService.demo(userId); &#125; /** * * 参数为对象示例方法 * @author wangxt * @date 2021/7/30 10:53 * @return ResponseInfo */ @ApiOperation(value = &quot;参数为对象示例方法&quot;) @GetMapping(&quot;demo4Po&quot;) public ResponseInfo&lt;DemoVo&gt; demo4Po(@ApiParam(name = &quot;参数&quot;, required = true) @RequestBody DemoPo demoPo)&#123; return demoService.demo4Po(demoPo); &#125;&#125; Po123456789101112131415161718package com.wangxt.springbootswaggerspring4all.domain.po;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;/** * * 示例入参 Po * @author wangxt * @date 2021/7/30 10:43 */@ApiModel(&quot;示例 Po&quot;)@Datapublic class DemoPo &#123; @ApiModelProperty(value = &quot;用户ID&quot;, required = true, example = &quot;1&quot;) private Integer userId;&#125; Vo1234567891011121314151617181920212223242526272829303132package com.wangxt.springbootswaggerspring4all.domain.vo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.time.LocalDateTime;import java.util.List;/** * * 示例 Vo * @author wangxt * @date 2021/7/30 10:33 */@ApiModel(&quot;示例 Vo&quot;)@Datapublic class DemoVo &#123; @ApiModelProperty(value = &quot;用户ID&quot;, required = true, example = &quot;1&quot;) private Integer userId; @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;wangxt&quot;) private String username; @ApiModelProperty(value = &quot;网站&quot;, required = false, example = &quot;wangxt.online&quot;) private String website; @ApiModelProperty(value = &quot;年龄&quot;, required = false, example = &quot;18&quot;, name = &quot;userAge&quot;) private Integer age; @ApiModelProperty(value = &quot;生日&quot;, required = false, example = &quot;8888-88-88&quot;, dataType = &quot;string&quot;) private LocalDateTime birthday; @ApiModelProperty(value = &quot;朋友&quot;, required = false, example = &quot;[\\&quot;A\\&quot;,\\&quot;B\\&quot;,\\&quot;C\\&quot;]&quot;) private List&lt;String&gt; friends;&#125; 启动项目，访问页面默认页面地址：http://{ip}:{port}/swagger-ui.html 我的示例地址查看（地址是内网穿透到我本机的，大概率访问不通（斜眼笑）） 页面截图 示例项目源码点我查看 总结到此，springboot项目整合swagger就完成了，整体配置相对原生的swagger2确实简单一些，只需要填写配置文件的参数即可，使用起来没有太大差别。默认的页面主题还是有些不友好（个人感觉）可以自己找个好看的ui换上，下篇换主题。 插曲第一次启动项目时报错，报错日志 123456java.lang.IllegalStateException: Failed to load ApplicationContextCaused by: org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is com.google.common.util.concurrent.ExecutionError: com.google.common.util.concurrent.ExecutionError: java.lang.NoClassDefFoundError: javax/validation/constraints/MinCaused by: com.google.common.util.concurrent.ExecutionError: com.google.common.util.concurrent.ExecutionError: java.lang.NoClassDefFoundError: javax/validation/constraints/MinCaused by: com.google.common.util.concurrent.ExecutionError: java.lang.NoClassDefFoundError: javax/validation/constraints/MinCaused by: java.lang.NoClassDefFoundError: javax/validation/constraints/MinCaused by: java.lang.ClassNotFoundException: javax.validation.constraints.Min 原因是swagger引用到了javax.validation包下的类，但是我新建的springboot项目并没有集成这个包，所以引下pom就行了 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"小试牛刀","slug":"小试牛刀","permalink":"http://blog.wangxt.online/categories/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"}],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"http://blog.wangxt.online/tags/Swagger/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.wangxt.online/tags/springboot/"},{"name":"接口文档","slug":"接口文档","permalink":"http://blog.wangxt.online/tags/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"}]},{"title":"cad破解","slug":"cad","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:06:33.472Z","comments":true,"path":"2022/12/04/cad/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/cad/","excerpt":"由于对象是工程专业，需要用到cad软件，奈何公司也不给补助购买正版，那咱只能使用破解版了，整理了一下cad2020的破解步骤，其它版本也基本类似，做个备份","text":"由于对象是工程专业，需要用到cad软件，奈何公司也不给补助购买正版，那咱只能使用破解版了，整理了一下cad2020的破解步骤，其它版本也基本类似，做个备份 软件下载地址 ：链接：https://pan.baidu.com/s/100omUwKALn63KugkmDdWUQ 1.解压压缩包 2.运行安装CAD2020 3.解压安装程序 4.正在解压安装程序 5.点击安装 6.我接受，下一步 7.选择安装路径 8.正在安装 9.忽略资源管理器 10.安装成功 11.重新启动 12.输入序列号 13.我同意 14.点击激活 15.输入序列号【666-69696969】 16.关闭页面 17.再次点击激活 18.再次输入序列号【666-69696969】 19.点击我具有激活码 20.运行注册机 21.修补注册机 22.复制申请号 23.粘贴申请号 24.生成激活码 25.粘贴激活码 26.点击下一步 27.许可激活成功","categories":[{"name":"生活","slug":"生活","permalink":"http://blog.wangxt.online/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"破解软件","slug":"破解软件","permalink":"http://blog.wangxt.online/tags/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"}]},{"title":"JDK动态代理详解","slug":"JDK动态代理","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:10:26.462Z","comments":true,"path":"2022/12/04/JDK动态代理/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"使用创建接口 123public interface Father &#123; void eat();&#125; 创建实现类 1234567public class Son implements Father&#123; @Override public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125;&#125; 测试 12345678910111213141516171819202122232425public class ProxyTest &#123; public static void main(String[] args) &#123; ProxyTest test = new ProxyTest(); test.jdkProxy(); &#125; private void jdkProxy()&#123; Father son = new Son(); Father proxySon = (Father) Proxy.newProxyInstance(son.getClass().getClassLoader(), son.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;做饭&quot;); Object invoke = method.invoke(son, args); System.out.println(&quot;洗碗&quot;); return invoke; &#125; &#125;); proxySon.eat(); &#125; 输出结果 123做饭吃饭洗碗 如上，是一个使用JDK动态代理的简单例子，通过Proxy类的静态方法newProxyInstance可以生成目标类的代理类，这里有几个疑问： 为什么要使用实例对象的ClassLoader和Interfaces，使用其实例对象的行不行，使用类的行不行 为什么被代理类非要实现接口 newProxyInstance返回的代理类是什么类型，强转成实现类（Father proxySon = (Son) Proxy.newProxyInstance(…)）会不会报错 我们带着这几个问题看看源码 源码java.lang.reflect.Proxy1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); // 克隆被代理类的接口Class对象 final Class&lt;?&gt;[] intfs = interfaces.clone(); // 使用Java安全管理器校验程序，防止恶心代码 final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 查找或生成指定的代理类。这里会使用缓存，缓存里没有就创建代理类，放放到缓存中 * 接下来我们进入这个方法看看 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. * 使用指定的调用处理程序调用其构造函数。 */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 获取代理类的构造器，这里会生成一个入参为InvocationHandler.class的构造器 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 通过反射使用构造方法（带有InvocationHandler入参的构造方法）创建代理类的实例对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 12345678910111213141516private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; // 这里为什么是65535？ if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory /** * 如果给定加载器定义的代理类实现,给定的接口存在，这将简单地返回缓存的副本；否则，它将通过 ProxyClassFactory 创建代理类 * 在进入这个方法看看 / return proxyClassCache.get(loader, interfaces); &#125; java.lang.reflect.WeakCache123456789101112131415161718192021222324252627public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap // 其它代码先不关注，这里的apply方法会调用$ProxyClassFactory的apply方法 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; ... &#125; java.lang.reflect.Proxy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names // 代理类名前缀 private static final String proxyClassNamePrefix = &quot;$Proxy&quot;; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; // 循环获取被代理类的接口结合的Class对象 interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + &quot; is not visible from class loader&quot;); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + &quot; is not an interface&quot;); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( &quot;repeated interface: &quot; + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf(&#x27;.&#x27;); String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( &quot;non-public interfaces from different packages&quot;); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); // com.sun.proxy. + $Proxy + 0 String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. * 生成指定的代理类文件，并判断是否需要持久化，这里只是普通的文件字节数组，jvm并不认识 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; // 定义代理类，加载到jvm中，生成真正可以使用的运行时代理类的Class对象， return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; 分析byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);这块代码可以生成代理类的字节数组，那么我们是不是可以看看生成的代理类到底长什么样呢？写个测试方法看看 1234567891011private void write()&#123; Father father = new Son(); byte[] proxyArr = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, father.getClass().getInterfaces()); try &#123; Files.write(Paths.get(&quot;C:\\\\Users\\\\wxt\\\\Desktop\\\\test.class&quot;), proxyArr); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 文件内容 12345678910111213141516171819202122232425262728293031323334353637383940414243// 代理类默认继承了Proxy类，实现了被代理类的接口public final class $Proxy0 extends Proxy implements Father &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; static &#123; try &#123; // 这里初始化4个成员变量 m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m3 = Class.forName(&quot;com.wangxt.wxt.design.patterns.proxy.dynamic.Father&quot;).getMethod(&quot;eat&quot;); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125; public $Proxy0(InvocationHandler var1) throws &#123; // 这里会调用父类的构造，并把InvocationHandler传递 super(var1); &#125; // 这里是我们自定义的方法，其它方法道理相同 public final void eat() throws &#123; try &#123; // 可以看到，当我们调用代理类的方法时，实际上会调用父类的h(InvocationHandler)的invoke方法 // @Override // public Object invoke(Object proxy, Method method, Object[] args) throws Throwable // 所以我们重写InvocationHandler的invoke方法时传入的就是这几个参数 super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; ...&#125; 好了，到这里基本信息都看完了，我们做个总结 准备代理类的描述数据 创建代理类（实现接口）的字节码文件 通过ClassLoader将代理类的字节数组加载到JVM中 创建代理类的实例对象，执行对象的目标方法 我们回过头来，在想想最开始的3个问题： 为什么要使用实例对象的ClassLoader和Interfaces，使用其实例对象的行不行，使用类的行不行 因为我们要代理的接口是应用类加载器加载的，所以理论上只要应用类加载器加的类都可以 但是interface肯定是需要实例对象(son.getClass())或者代理类(Son.class)，因为我们要对其的接口进行代理 为什么被代理类非要实现接口 因为代理类已经继承了Proxy类，所以只能实现接口 newProxyInstance返回的代理类是什么类型，强转成实现类（Father proxySon = (Son) Proxy.newProxyInstance(…)）会不会报错 返回的是实现了接口继承了Proxy的代理类，所以强转成Son会报错 总结因为JDK动态代理生成的代理对象默认继承了Proxy类，又因为Java中是单继承多实现，所以导致了JDK动态代理无法代理实现类，只能代理接口；而且我们通过观察Proxy类，维护了InvocationHandler h成员变量并提供了相应的方法，然后通过子类对InvocationHandler进行透传，Proxy对其进行方法执行，其实理论上只要我们把InvocationHandler提出来，不由Proxy进行维护，也就不需要继承Proxy类，就可以对实现类进行代理，可能作者基于面向接口开发的实际场景，以及抽象思维才这么进行设计的吧。","categories":[{"name":"思考总结","slug":"思考总结","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"},{"name":"jdk源码","slug":"思考总结/jdk源码","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/jdk%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.wangxt.online/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"源码","slug":"源码","permalink":"http://blog.wangxt.online/tags/%E6%BA%90%E7%A0%81/"},{"name":"AOP","slug":"AOP","permalink":"http://blog.wangxt.online/tags/AOP/"}]},{"title":"windows 批量启动软件脚本","slug":"quick_start_bat","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:11:11.346Z","comments":true,"path":"2022/12/04/quick_start_bat/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/quick_start_bat/","excerpt":"公司预备使用的是windows系统主机办公，每天早上来了第一件事就是开机，启动软件，启动软件，启动…，个人不太喜欢使用软件的开机自启动，于是有了这个脚本。","text":"公司预备使用的是windows系统主机办公，每天早上来了第一件事就是开机，启动软件，启动软件，启动…，个人不太喜欢使用软件的开机自启动，于是有了这个脚本。 代码123456789101112@echo offtitle quick startstart /d &quot;D:\\software\\WeChat\\&quot; WeChat.exeecho starting weChatchoice /t 3 /d y /n &gt;nulstart /d &quot;D:\\software\\WXWork\\&quot; WXWork.exeecho starting wxWorkchoice /t 3 /d y /n &gt;nulstart /d &quot;D:\\software\\Clash for Windows\\&quot; Clash.exeecho starting clashchoice /t 3 /d y /n &gt;nulecho start over bye~ 使用 新建一个start.txt文件，修改文件后缀名为start.bat 右击软件，右击选择编辑，将代码复制过去 将代码中的路径和软件名称替换成你自己的 注意 软件名称不要有空格，否则会报错","categories":[{"name":"效率提升","slug":"效率提升","permalink":"http://blog.wangxt.online/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"bat","slug":"bat","permalink":"http://blog.wangxt.online/tags/bat/"},{"name":"脚本","slug":"脚本","permalink":"http://blog.wangxt.online/tags/%E8%84%9A%E6%9C%AC/"},{"name":"便捷开发","slug":"便捷开发","permalink":"http://blog.wangxt.online/tags/%E4%BE%BF%E6%8D%B7%E5%BC%80%E5%8F%91/"}]},{"title":"一键重置git分支脚本","slug":"reset-git-branch","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:11:37.362Z","comments":true,"path":"2022/12/04/reset-git-branch/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/reset-git-branch/","excerpt":"由于公司的上线封版机制，每个上线窗口结束之后，需要将qa和develop分支切换成上个窗口的beta灰度分支，虽然逻辑很简单，但是处理起来还有有点小繁琐，所以写了一个脚本干这个事，其实就是将用到的git命令打包，叫脚本去执行了自己本该执行的git命令，简单记录一下","text":"由于公司的上线封版机制，每个上线窗口结束之后，需要将qa和develop分支切换成上个窗口的beta灰度分支，虽然逻辑很简单，但是处理起来还有有点小繁琐，所以写了一个脚本干这个事，其实就是将用到的git命令打包，叫脚本去执行了自己本该执行的git命令，简单记录一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/env bashif [ $# -le 3 ] then echo &quot;参数有误(&#123;源分支&#125;,&#123;重置分支&#125;,&#123;本地项目根目录&#125;,&#123;项目名称(api/www)&#125;) 举例：&quot; echo &quot;8.29.1.0 qa D:/wangxt-git api&quot; exitfiif [ -z $2 ] then LIST=(qa,develop) else LIST=($2)fiif [ -z $3 ] then WORK_PATH=D:/wangxt-git else WORK_PATH=$3fiif [ &quot;api&quot; = $4 ] then P_NAME=/api F_NAME=/framework else P_NAME=/www F_NAME=/frameworkfiecho &quot;===============================================================&quot;echo &quot;= 项目名称: &quot;$P_NAME&quot; &quot;echo &quot;= &quot;$F_NAME&quot; &quot;echo &quot;= 源分支: &quot;$1&quot; &quot;echo &quot;= 要重置的分支: &quot;$LIST&quot; &quot;echo &quot;= 你的项目绝对路径: &quot;$3&quot; &quot;echo &quot;===============================================================&quot;echo &quot;以上信息，确定正确码？请输入序号&quot;select yn in &quot;正确,开始执行&quot; &quot;错误,退出程序&quot;; do case $yn in 正确,开始执行 ) echo &quot;!!!!准备进入&quot;$3&quot;目录&quot; cd WORK_PATH echo &quot;当前工作目录：&quot;`pwd` echo &quot;-------- api-framework 开始 -------&quot; cd $WORK_PATH$F_NAME echo &quot;当前工作目录：&quot;`pwd` git checkout -b $1.temp4shell remotes/origin/$1 for i in $LIST do echo &quot;!!!!尝试删除本地分支：&quot;$i git checkout -b $1.temp4shell git pull git branch -D $i echo &quot;!!!!忽略上边报错&quot; git checkout -b $i remotes/origin/$i echo &quot;!!!!重新检出分支：&quot;$i git branch -D $i git push origin --Delete $i echo &quot;!!!! &quot;$i&quot; 分支删除完毕&quot; git checkout -b $1 remotes/origin/$1 git pull git checkout -b $i git push -u origin $i echo &quot;!!!! &quot;$i&quot; 分支已从 &quot;$1&quot; 分支检出&quot; done git branch -D $1.temp4shell git push origin --Delete $1.temp4shell echo &quot;------- api-framework 结束 -------&quot; echo &quot;=================================&quot; echo &quot;--------- api 开始 ---------&quot; cd $WORK_PATH$P_NAME echo &quot;当前工作目录：&quot;`pwd` git checkout -b $1.temp4shell remotes/origin/$1 for i in $LIST do echo &quot;!!!!尝试删除本地分支：&quot;$i git checkout -b $1.temp4shell git pull git branch -D $i echo &quot;!!!!忽略上边报错&quot; git checkout -b $i remotes/origin/$i echo &quot;!!!!重新检出分支：&quot;$i git branch -D $i git push origin --Delete $i echo &quot;!!!! &quot;$i&quot; 分支删除完毕&quot; git checkout -b $1 remotes/origin/$1 git pull git checkout -b $i git push -u origin $i echo &quot;!!!! &quot;$i&quot; 分支已从 &quot;$1&quot; 分支检出&quot; done git branch -D $1.temp4shell git push origin --Delete $1.temp4shell echo &quot;-------- api end --------&quot; echo &quot;理论上 &quot;$4&quot; 项目的 &quot;$LIST&quot; 已重置完成，请到 gitlab 验收结果!!!&quot; echo &quot;&quot; echo &quot;Bye~&quot;; break;; 错误,退出程序 ) echo &quot;Bye~&quot;;exit;; esacdone","categories":[{"name":"效率提升","slug":"效率提升","permalink":"http://blog.wangxt.online/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://blog.wangxt.online/tags/shell/"},{"name":"git branch","slug":"git-branch","permalink":"http://blog.wangxt.online/tags/git-branch/"}]},{"title":"一个聚合浏览器打开的标签的插件","slug":"一个聚合浏览器打开的标签的插件","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:05:12.756Z","comments":true,"path":"2022/12/04/一个聚合浏览器打开的标签的插件/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E4%B8%80%E4%B8%AA%E8%81%9A%E5%90%88%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%9A%84%E6%A0%87%E7%AD%BE%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"前言：对于我们这些面向google编程的程序猿来说，浏览器会时常打开超多的标签页，当我们想回到某个标签页时很麻烦，很不好找，所以搞了这个浏览器插件 – 一步","text":"前言：对于我们这些面向google编程的程序猿来说，浏览器会时常打开超多的标签页，当我们想回到某个标签页时很麻烦，很不好找，所以搞了这个浏览器插件 – 一步 用法克隆项目1git clone https://github.com/wxt1471520488/one-step.git 在浏览器插件中引用 使用","categories":[{"name":"效率提升","slug":"效率提升","permalink":"http://blog.wangxt.online/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"实用功能","slug":"实用功能","permalink":"http://blog.wangxt.online/tags/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"name":"Chrome插件","slug":"Chrome插件","permalink":"http://blog.wangxt.online/tags/Chrome%E6%8F%92%E4%BB%B6/"}]},{"title":"代码实现单表的分库分表","slug":"代码实现单表的分库分表","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T06:56:32.785Z","comments":true,"path":"2022/12/04/代码实现单表的分库分表/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%A8%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/","excerpt":"线上业务上由于单表的数据量越来越大，并且随着用户的增长，表数据量的增长率可能还会增高，所以想着对单表进行分表，然后将整个分表的缘由以及分表方案的确定记录一下","text":"线上业务上由于单表的数据量越来越大，并且随着用户的增长，表数据量的增长率可能还会增高，所以想着对单表进行分表，然后将整个分表的缘由以及分表方案的确定记录一下 啥叫分库分表？简单点说就是当我们遇到访问极为频繁且数据量巨大的库表的时候，我们首先想到的就是减少单库单表的数据量，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分库分表。 为什么要都开始考虑起来分库分表？当我们在开发一些用户量小的系统时，比如公司自用的后台系统，相对是比较轻松的，因为你无需特别专注的考虑高并发，高访问，大数据量等问题，所以对于数据库乃至一些表的设计，对当用户量比较小时还可以跑的通，但是随着量越来越大，动不动就上千万，上亿的数据，光靠加索引或对sql往死里优化还是远远不够的，这时候我们就该考虑是否到了对数据库需要进行分库分表的时候了，当然决定了一定要速战速决，因为数据量增长的速度比你犹豫的速度要快的多。 如何进行分库分表？ 对于分库分表，现在基本都是水平分和垂直分：(1)水平分就是根据一定规则，例如按照时间或业务唯一ID等对数据进行的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据会平均，从而提升性能；(2)垂直分就是按照业务进行划分，例如将用户相关的放一个库，订单相关的放一个库。 1.分库： 先来讨论下分库，很多项目一开始基本都是一个库，各种业务的表都在一起，随着表越来越多，变得越来越来不好维护，老表新表掺杂在一起，一些废弃的表也没有及时做清理(我真的要吐了，所以文档是多么的重要)。对于分库，我现在使用较多的是垂直分，按照业务分，比如我们将和用户端无用的一些用于统计的表单独放在一个库里，这样做好处是这些统计表不会参与用户测相关表的join查询操作，并且对于统计表进行需要进行大量计算，这样其实可以更放心的去查数据算数据不用担心影响到用户测的业务，所以对于类似的表进行垂直分库是完全没有问题的。对于水平分库目前没有实践，只是懂一些原理，就…. 简单点说就是当我们遇到访问极为频繁且数据量巨大的库表的时候，我们首先想到的就是减少单库单表的数据量，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分库分表。 2.分表：(1)对于向用户ID这样的数值类型我们可以对要分的表的数量取余(userId % count)来进行分表，根据这个路由策略，可以将记录根据userId路由到不同的表中，达到分表的母的。路由帮助方法示例代码： 123456789101112131415161718// 分表基数private static final Integer COUNT = 20;/** * @desc 根据用户ID获取分表后缀 * @author dataozi * @date 2020/4/11 15:22 * @param userId 用户ID * @return 表后缀 * @throws RuntimeException 用户ID参数异常 */public static String getSuffixByUserId(Long userId)&#123; if(Objects.isNull(userId) || userId &lt;= 0)&#123; throw new RuntimeException(String.format(&quot;用户ID有误 , userId : %s&quot;, userId)); &#125; return String.format(&quot;_g0_p%s&quot;, userId % COUNT);&#125; 可能大家有疑问，为什么表后缀是”_g0_p0”，这样目的是为了以后可能会再次进行分表，因为这种方式最大的弊端就是我们需要预先确定下表的数量，但是随着量的增长，及时现在分了，以后还是会有再次达到记录阈值的那天；以后如果需要再次进行分表的话，我可以修改为”_g1”再次实现分表。 (2)上边是定表，不定单表记录量的，我们还可以讨论下定表记录数，不行表的。就是我们规定每张表最大数据量假如为100w，那么当第一张表数据量达到后自动开始向下张表存数据。如何实现呢，其实思想大同小异，我们可以维护一个全局的记录总数，每次获取表后缀时判断是否需要取新的表，路由帮助方法示例代码： 123456789101112131415161718// 单张表记录的最大数量private static final long COUNT = 1000000L;/** * @desc 获取表的坐标 * @author dataozi * @date 2020/4/11 16:15 * @param count 当前记录数 * @return 表坐标 * @throws RuntimeException 记录数参数异常 */public static int getTableIndexVal(long count)&#123; if (count &lt;= 0) &#123; throw new RuntimeException(&quot;记录数有误&quot;); &#125; long index = count % COUNT == 0 ? count / COUNT - 1 : count / COUNT; return (int) index;&#125; 需要注意的是一定要在业务记录量达到阈值之前创建新表，我们可以起个定时任务，在表记录达到90w时就创建下张表，预先创建表。 (3)对于向UUID这样的我们可以取UUID的最后一位或最后两位进行分表，以最后一位举例，我们知道UUID是一个数字和字母组成的伪随机字段串，这样的话最后一位就是0-9a-z(26 + 10)，可以建立36张表，同上，表后缀可以是”_g0_pa”，大家没有问题吧。哈哈，坑来了，强调一下，UUID 是由一组32位数的16进制数字所构成，所以不是26个字母只有a-f，所以即使按照这种方式创建了表，也是永远用不到的，所以每个小知识点都要熟透啊，我就是对UUID没怎么真正了解，结果…；话说回来，这样的方式确实表的量是死的，那么怎么也变成稍微活一点呢? (4)我们取UUID的hashcode，这样我们又得到了一个数值类型的唯一标识，同理我们可以这样做，路由帮助方法示例代码： 1234567891011121314151617181920// 分表基数private static final Integer COUNT = 20;/** * @desc 根据uuid获取表后缀 * @author dataozi * @date 2020/4/11 15:41 * @param uuid uuid * @return 表后缀 * @throws RuntimeException uuid参数异常 */public static String getSuffixByUserId(String uuid)&#123; if (StringUtils.isBlank(uuid)) &#123; throw new RuntimeException(&quot;designID 为空&quot;); &#125; // 取uuid的hashcode绝对值对20取模的值 int code = uuid.toLowerCase().hashCode(); return String.format(&quot;_g0_p%s&quot;, Math.abs(code) % COUNT);&#125; (5)除了上边这种通过唯一标识进行水平分的，我们还可以通过日期进行分表，比如上边提到的一些统计数据表，表本身没有什么业务逻辑，只需要按照日期定期进行数据统计，那我们通过日期进行分表再好不过了；我们按照季度进行分表，一年4张统计数据表，这样分表最好定个闹铃，每个月提醒建表，或者你一次性建个几十年的，O(∩_∩)O哈哈~，路由帮助方法示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 临时年份值private static int tempYearByYearAndSeason;// 临时月份值private static Month tempMonthByYearAndSeason;// 临时表名称后缀private static String tempNameSuffixByYearAndSeason;/** * @desc 获取表后缀 * @author dataozi * @date 2020/4/11 15:49 * @param year 年 * @param month 月 * @return 表后缀 */public static String calcNameSuffix(int year, Month month) &#123; // 计算当前属于那个季度，从0开始 int quarterCount = 0; switch (month) &#123; case JANUARY: case FEBRUARY: case MARCH: break; case APRIL: case MAY: case JUNE: quarterCount += 1; break; case JULY: case AUGUST: case SEPTEMBER: quarterCount += 2; break; case OCTOBER: case NOVEMBER: case DECEMBER: quarterCount += 3; break; default: throw new RuntimeException(&quot;system error&quot;); &#125; return String.format(&quot;_g%s_p%s&quot;, year, quarterCount);&#125;/* 设置初始值 */static &#123; LocalDate now = LocalDate.now(); tempNameSuffixByYearAndSeason = calcNameSuffix(now.getYear(), now.getMonth()); tempYearByYearAndSeason = now.getYear(); tempMonthByYearAndSeason = now.getMonth();&#125;/** * @desc 获取表后缀 * @author dataozi * @date 2020/4/11 15:51 * @return 表后缀 */public static String getNameSuffixByYearAndSeason() &#123; LocalDate now = LocalDate.now(); int year = now.getYear(); Month month = now.getMonth(); // 当年月份交替时需要重置静态数据 if (year == tempYearByYearAndSeason &amp;&amp; month.equals(tempMonthByYearAndSeason)) &#123; return Objects.requireNonNull(tempNameSuffixByYearAndSeason); &#125; tempNameSuffixByYearAndSeason = calcNameSuffix(year, month); tempYearByYearAndSeason = year; tempMonthByYearAndSeason = month; return tempNameSuffixByYearAndSeason;&#125; 分库分表之后，主键ID该怎么维护？上边我们通过简单的代码，基本已经实现了分库分表，不要高兴太早，原来单表时，我们是有主键ID的，一般都是自增ID，那么进行分表之后，每张表都会有各自的主键自增ID，那么怎么维护一个全局的主键ID呢，下面我们在讨论一下这个问题： ​ (1)利用数据库本身。我们可以在单独创建一张ID表，每次在新增数据时，先向ID表中插入一条数据，获取最新主键ID之后再向分表中插入业务数据；基本这只是一个思路，面临获取ID的性能、ID表记录会无限多等问题不考虑线上使用 ​ (2)利用Redis。利用redis的incr命令，每次在插入数据之前，先从redis获取到id，下次获取自动累计，达到自增的作用。示例代码： 123456789101112131415161718192021// redis存储全局自增主键ID的keyprivate static final String TABLE_RECORD_COUNT_KEY = &quot;xxx-table.primary-key.record&quot;;/** * @desc 获取主键ID * @author dataozi * @date 2020/4/11 16:20 * @return 数量 */public static long incr() &#123; // cache是我们封装的jedis帮助类 if (cache == null) &#123; // 这里加锁，防止多个线程同时设置 synchronized (XXXX.class) &#123; if (cache == null) &#123; cache = cacheDef.getCACHE19(); &#125; &#125; &#125; return cache.incr(TABLE_RECORD_COUNT_KEY);&#125; (3)其它一些较成熟的自增id的类库，因为没线上实践过，所以…略过 如何对已有表进行分表？对于一些新表好说，我们可以都设计好了在去上线使用，但是我们实际在分表时，有很多是已经在业务使用的表，已经使用的表如何分表呢？这里讨论的是怎么实现由老表向新表的过渡。 (1)停止服务 告诉用户我们要大更新，晚上几点到几点暂停运营，然后在这期间老表没有了新数据的插入，我们可以很方便将历史数据同步到新表，在部署代码，充分测试上线。看似没有任何问题是吧，最大的问题就是方案本身的问题，我们停止了服务，举个不恰当的例子，你怎么判断你的电脑有没有网，是不是打开百度或google随便搜个啥东西，从另外一个方面体现出人家的服务是多么的稳定，所以只要有其它方案，我们绝不考虑停机去干一些事情。 (2)双向同步 不停机我们怎么实现新老表的平滑过渡呢，我们需要先在老表插入数据的地方同步向新表插入并上线，这样入口打通了，然后是历史数据，在搞个定时任务去同步历史数据，等历史数据同步完之后，新表数据和老表就完全一致了，因为历史数据有了，并且新数据会同步向新老表插入，最后一步就是修改查询，将所有从老表查询的地方改为从新表查询，同时去掉向老表插入数据的代码上线，这样老表没有任何使用的地方，任由处置。","categories":[{"name":"思考总结","slug":"思考总结","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"},{"name":"数据库优化","slug":"思考总结/数据库优化","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"http://blog.wangxt.online/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"http://blog.wangxt.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"使用ssh登录远程服务器报错","slug":"使用ssh登录远程服务器报错","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T06:57:36.664Z","comments":true,"path":"2022/12/04/使用ssh登录远程服务器报错/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E4%BD%BF%E7%94%A8ssh%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99/","excerpt":"今天使用ssh远程链接远程服务器时，突然报错了，记录一下原因","text":"今天使用ssh远程链接远程服务器时，突然报错了，记录一下原因 原因是我的远程服务器进行了重置，导致本地记录的验证信息过时了。 有两个办法可以解决： 删除本地验证信息，看图我们可以知道验证信息就是/Users/wangxiaotao/.ssh/known_hosts 的known_hosts文件；执行命令 rm -rf./known_hosts将验证信息删除,或者将远程服务器对应的配置信息删除； 不想改动known_hosts文件的话，可以利用 ssh-keygen -R [远程机器ip]:port 这个命令来删掉关于特定的远程机器的host信息。","categories":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"SHH","slug":"SHH","permalink":"http://blog.wangxt.online/tags/SHH/"}]},{"title":"修改已经运行的docker容器的端口","slug":"修改运行中的docker容器端口","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:04:05.471Z","comments":true,"path":"2022/12/04/修改运行中的docker容器端口/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E4%BF%AE%E6%94%B9%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84docker%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3/","excerpt":"一开始博客没有加Nginx，我把docker容器直接映射到了宿主机的80端口，后来加入了Nginx来管理静态资源、ssl等，这时候80端口被占用了，所以需要修改正在运行的docker容器映射的宿主机的端口，记录一下修改方法","text":"一开始博客没有加Nginx，我把docker容器直接映射到了宿主机的80端口，后来加入了Nginx来管理静态资源、ssl等，这时候80端口被占用了，所以需要修改正在运行的docker容器映射的宿主机的端口，记录一下修改方法 一、删除原有容器，重新启动一个容器把原来的容器删掉，重新启动一个，完了启动修改 端口映射 -p 为新的端口。 这里我就不演示了，因为我没用这个方法，懒得重新配置一遍…. 二、修改原有容器配置文件中的端口映射12345678910111213141516# 获取正在运行的dokcer容器[root@iZ8vb7tm9o88h6ioml28vsZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77e6bfccd1cd hexo-image &quot;docker-entrypoint.s…&quot; 10 days ago Up 36 hours 0.0.0.0:4000-&gt;4000/tcp, :::4000-&gt;4000/tcp hexo-blog# 我们先停掉正在运行的docker容器[root@iZ8vb7tm9o88h6ioml28vsZ containers]# docker stop hexo-blog# 然后进入docker容器配置的容器列表路径，这里显示了我们运行过的容器的HASH值[root@iZ8vb7tm9o88h6ioml28vsZ ~]# cd /var/lib/docker/containers/[root@iZ8vb7tm9o88h6ioml28vsZ containers]# lltotal 16drwx-----x 4 root root 4096 Jun 29 22:24 0689cb3baaf4adfc9f1b7a30327080a584faebdb6af3a29ad02a9f987f419869drwx-----x 4 root root 4096 Jun 29 22:24 1d0449bb8923092474efbdc6c9b65097898131105e7d5ea12809883a752fa407drwx-----x 4 root root 4096 Jun 29 22:24 77e6bfccd1cd7cb85dc9548e507caf99052b80c95889304d6219ba54b894b896drwx-----x 4 root root 4096 Jun 29 22:24 cf57f70841c097654c76787478a0648722ac8c9a0d9f88738495c36de4fc2ea5# 这时我们进入以上边查询到容器的CONTAINER ID开头的文件夹，并打开 hostconfig.json 配置文件[root@iZ8vb7tm9o88h6ioml28vsZ containers]# vim 77e6bfccd1cd7cb85dc9548e507caf99052b80c95889304d6219ba54b894b896/hostconfig.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; &quot;Binds&quot;:[ &quot;/usr/hexo-blog/my-blog/:/usr/blog/my-blog/&quot;, &quot;/usr/hexo-blog/:/usr/blog&quot; ], &quot;ContainerIDFile&quot;:&quot;&quot;, &quot;LogConfig&quot;:&#123; &quot;Type&quot;:&quot;json-file&quot;, &quot;Config&quot;:&#123; &#125; &#125;, &quot;NetworkMode&quot;:&quot;default&quot;, &quot;PortBindings&quot;:&#123; &quot;80/tcp&quot;:[ &#123; &quot;HostIp&quot;:&quot;&quot;, &quot;HostPort&quot;:&quot;80&quot; &#125; ] &#125;, &quot;RestartPolicy&quot;:&#123; &quot;Name&quot;:&quot;no&quot;, &quot;MaximumRetryCount&quot;:0 &#125;, &quot;AutoRemove&quot;:false, &quot;VolumeDriver&quot;:&quot;&quot;, &quot;VolumesFrom&quot;:null, &quot;CapAdd&quot;:null, &quot;CapDrop&quot;:null, &quot;CgroupnsMode&quot;:&quot;host&quot;, &quot;Dns&quot;:[ ], &quot;DnsOptions&quot;:[ ], &quot;DnsSearch&quot;:[ ], &quot;ExtraHosts&quot;:null, &quot;GroupAdd&quot;:null, &quot;IpcMode&quot;:&quot;private&quot;, &quot;Cgroup&quot;:&quot;&quot;, &quot;Links&quot;:null, &quot;OomScoreAdj&quot;:0, &quot;PidMode&quot;:&quot;&quot;, &quot;Privileged&quot;:false, &quot;PublishAllPorts&quot;:false, &quot;ReadonlyRootfs&quot;:false, &quot;SecurityOpt&quot;:null, &quot;UTSMode&quot;:&quot;&quot;, &quot;UsernsMode&quot;:&quot;&quot;, &quot;ShmSize&quot;:67108864, &quot;Runtime&quot;:&quot;runc&quot;, &quot;ConsoleSize&quot;:[ 0, 0 ], &quot;Isolation&quot;:&quot;&quot;, &quot;CpuShares&quot;:0, &quot;Memory&quot;:0, &quot;NanoCpus&quot;:0, &quot;CgroupParent&quot;:&quot;&quot;, &quot;BlkioWeight&quot;:0, &quot;BlkioWeightDevice&quot;:[ ], &quot;BlkioDeviceReadBps&quot;:null, &quot;BlkioDeviceWriteBps&quot;:null, &quot;BlkioDeviceReadIOps&quot;:null, &quot;BlkioDeviceWriteIOps&quot;:null, &quot;CpuPeriod&quot;:0, &quot;CpuQuota&quot;:0, &quot;CpuRealtimePeriod&quot;:0, &quot;CpuRealtimeRuntime&quot;:0, &quot;CpusetCpus&quot;:&quot;&quot;, &quot;CpusetMems&quot;:&quot;&quot;, &quot;Devices&quot;:[ ], &quot;DeviceCgroupRules&quot;:null, &quot;DeviceRequests&quot;:null, &quot;KernelMemory&quot;:0, &quot;KernelMemoryTCP&quot;:0, &quot;MemoryReservation&quot;:0, &quot;MemorySwap&quot;:0, &quot;MemorySwappiness&quot;:null, &quot;OomKillDisable&quot;:false, &quot;PidsLimit&quot;:null, &quot;Ulimits&quot;:null, &quot;CpuCount&quot;:0, &quot;CpuPercent&quot;:0, &quot;IOMaximumIOps&quot;:0, &quot;IOMaximumBandwidth&quot;:0, &quot;MaskedPaths&quot;:[ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;:[ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ]&#125; 打开之后是个json，我们格式化，然后找到 PortBindings这个key，以我的配置为例，其中4000/tcp对应的是docker容器内部的端口，HostPort对应的是映射到宿主机的端口。这时候我们修改宿主机的端口为自己想修改的端口，然后重启docker服务，再启动容器服务就可以了。 1234# 重启docker服务[root@iZ8vb7tm9o88h6ioml28vsZ containers]# systemctl restart docker# 启动dokcer容器[root@iZ8vb7tm9o88h6ioml28vsZ containers]# docker start hexo-blog 三、将已有的docker容器再打包成一个镜像把已经配置好或者正在运行的容器，在打包成一个新的镜像，之后通个这个新镜像，重新启动一个80端口的容器，原有容器可以删除或者停掉。 123456789101112131415# 获取正在运行的dokcer容器[root@iZ8vb7tm9o88h6ioml28vsZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77e6bfccd1cd hexo-image &quot;docker-entrypoint.s…&quot; 10 days ago Up 36 hours 0.0.0.0:4000-&gt;4000/tcp, :::4000-&gt;4000/tcp hexo-blog# 我们先停掉正在运行的docker容器[root@iZ8vb7tm9o88h6ioml28vsZ containers]# docker stop hexo-blog# 将容器打包成镜像提交，命令是 docker commit 容器名字 新镜像名字:标签[root@iZ8vb7tm9o88h6ioml28vsZ containers]# docker commit hexo-blog wxt-hexo-blog:1.0sha256:79f63a5a9f30632ed1617083166b0504f633b47d84e36694be51029883a146d4# 这时候我们看已经有我们新的镜像了[root@iZ8vb7tm9o88h6ioml28vsZ containers]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEwxt-hexo-blog 1.0 79f63a5a9f30 8 seconds ago 950MB# 我们启动一下，映射新的80端口docker run --name new-hexo-blog -p 80:80 wxt-hexo-blog:1.0 四、总结 第一种：方式简单，干净利落，但是如果我们之前的容器中配置很多东西，需要从头重新配置一次，就很繁琐，如果容器很轻，没有什么东西，或者我们可以很迅速的配置一个新的容器，那第一种还是相对方便的； 第二种：不需要重新配置容器，操作也还是算简单，但是会短暂的停止整个dokcer服务，如果服务器内还有其他容器正在运行则也会受到影响；如果服务器内其它容器受到的影响可以忽略，那第二种是适合的； 第三种：相对前两种方法，不需要重新配置容器，也不会对其它容器造成影响，但是会多很多无用（我自认为是无用）的镜像，这个也是看自己关注不关注那些镜像吧。","categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://blog.wangxt.online/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"docker容器","slug":"docker容器","permalink":"http://blog.wangxt.online/tags/docker%E5%AE%B9%E5%99%A8/"}]},{"title":"数据库连接参数allowMultiQueries的作用","slug":"数据库连接参数allowMultiQueries的作用","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:00:47.962Z","comments":true,"path":"2022/12/04/数据库连接参数allowMultiQueries的作用/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0allowMultiQueries%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"如上，今天有个同事写了一条sql，先不管sql的业务逻辑和可用性，在本地执行没有问题，部署到QA环境报错，原因是本地数据库连接时设置了allowMultiQueries=true，但是QA环境没有设置，那默认是false。记录一下 allowMultiQueries 参数的作用","text":"如上，今天有个同事写了一条sql，先不管sql的业务逻辑和可用性，在本地执行没有问题，部署到QA环境报错，原因是本地数据库连接时设置了allowMultiQueries=true，但是QA环境没有设置，那默认是false。记录一下 allowMultiQueries 参数的作用 123456&lt;delete id=&quot;delete&quot;&gt; &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;;&quot; &gt; delete from xxxx_table where gid = #&#123;item.gId&#125; and pid = #&#123;item.pId&#125; &lt;/foreach&gt; &lt;/delete&gt; 如上，今天有个同事写了一条sql，先不管sql的业务逻辑和可用性，在本地执行没有问题，部署到QA环境报错，大概意思就是sql在where gid = #{item.gId} 执行语法有问题。 问题原因：本地数据库连接时设置了allowMultiQueries=true，但是QA环境没有设置，那默认是false。 allowMultiQueries=true的作用 可以在sql语句后携带分号，实现多语句执行。 可以执行批处理，同时发出多个SQL语句。 将QA环境的数据库连接加上这个属性就可以了。","categories":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wangxt.online/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.wangxt.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"填上IntegerCache的坑","slug":"填上IntegerCache的坑","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T07:01:59.706Z","comments":true,"path":"2022/12/04/填上IntegerCache的坑/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E5%A1%AB%E4%B8%8AIntegerCache%E7%9A%84%E5%9D%91/","excerpt":"如下代码，本地跑程序都没问题，一到线上就不行，原因就是IntegerCache的问题，比较两个Integer时，本地数据少，数值也小，正好都是true，正式数据多，可能就因为IntegerCache的问题导致该是true的为false了，导致程序的执行出错。","text":"如下代码，本地跑程序都没问题，一到线上就不行，原因就是IntegerCache的问题，比较两个Integer时，本地数据少，数值也小，正好都是true，正式数据多，可能就因为IntegerCache的问题导致该是true的为false了，导致程序的执行出错。 1234567//......Integer a = 200;Integer b = 200;if(a == b)&#123;//......&#125;//...... 我们直接看Integer类的源码： 1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125; 可以看到，Integer内部维护着IntegerCache的一个内部类，我们分析一下这个IntegerCache,它维护着两个静态int常量，和一个静态的Integer数组，然后静态块里初始化了high值和cache数组，并且将low到high中的数值add到了cache中，并且可以看到low值是常量-128,high值我们是可以通过配置文件配置的，也就是说我们可以根据jvm自行修改IntegerCache的阈值(最大值)，只是看IntegerCache的话发现很简单，接下来我们结合Integer的几个方法在分析一下： Integer的构造方法： 123public Integer(int value) &#123; this.value = value;&#125; Integer的parstInt方法： 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; Integer的parstInt方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static int parseInt(String s, int radix) throws NumberFormatException &#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException(&quot;null&quot;); &#125; if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException(&quot;radix &quot; + radix + &quot; less than Character.MIN_RADIX&quot;); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException(&quot;radix &quot; + radix + &quot; greater than Character.MAX_RADIX&quot;); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; &#x27;0&#x27;) &#123; // Possible leading &quot;+&quot; or &quot;-&quot; if (firstChar == &#x27;-&#x27;) &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != &#x27;+&#x27;) throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot; throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; result *= radix; if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result;&#125; 可以看到，通过Integer的构造方法创建Integer对象时，并不会跟IntegerCache扯上关系，也就是说创建多少个都是新对象，比较的话都是false，因为他们的地址值都不一样；parseInt方法返回的是int基本类型，所以跟IntegerCache也没有关系；我们再来看一下valueOf方法，在给定的IntegerCache的阈值范围内，Integer对象都是从cache数组中取到的，而内部类都是懒加载，在使用时加载内部类，并且创建阈值之内的所有Integer对象并存入cache中，cache是静态常量数组，由常量池维护着，cache被所有的Integer对象共享，所以只要是比较cache阈值之内的两个Integer的结果都是true，因为本身他们就是同一个对象。(ps:Integer a = 1; 默认调用的是valueOf方法)。 到此为止，我们应该对IntegerCache有了一定的了解，那么做点习题巩固一下： 12345678910111213141516171819202122Integer x = 1;Integer y = 1;System.out.println(String.format(&quot;1:%s&quot;,x == y));// 1x = 127;y = 127;System.out.println(String.format(&quot;2:%s&quot;,x == y));// 2x = 128;y = 128;System.out.println(String.format(&quot;3:%s&quot;,x == y));// 3x = new Integer(1);y = new Integer(1);System.out.println(String.format(&quot;4:%s&quot;,x == y));// 4x = Integer.parseInt(&quot;127&quot;);y = Integer.parseInt(&quot;127&quot;);System.out.println(String.format(&quot;5:%s&quot;,x == y));// 5x = Integer.parseInt(&quot;128&quot;);y = Integer.parseInt(&quot;128&quot;);System.out.println(String.format(&quot;6:%s&quot;,x == y));// 6x = new Integer(1);System.out.println(String.format(&quot;7:%s&quot;,x == y));// 7x = new Integer(128);System.out.println(String.format(&quot;8:%s&quot;,x == y));// 8 结果： 1:true 2:true 3:false 4:false 5:true 6:false 7:false 8:false 如果你都做对了，那么你对IntegerCache已经算是过关了，^_^！！！这里在说一下x = Integer.parseInt(“127”)和y = Integer.parseInt(“127”)这两个比较，因为parstInt()方法返回的是int基本类型,自动装箱，就变成了Integer x = 127;调用valueOf方法,所以判断结果和直接调用valueOf方法是一样的。 续：下边输出结果是什么 123456@Testpublic void test() &#123; Integer x = 1; Integer y = 1; System.out.println(x.equals(y));&#125; 上边x和y都是各自创建了一个新的Integer对象，两个引用对象去equals的话，一般是比较地址值，返回应该是false，但是像Integer和String这种类，都重写了equals方法，Integer的equals实际就是两个int基本类型的值比较，所以返回的是true。如下： 12345678910111213141516/** * Compares this object to the specified object. The result is * &#123;@code true&#125; if and only if the argument is not * &#123;@code null&#125; and is an &#123;@code Integer&#125; object that * contains the same &#123;@code int&#125; value as this object. * * @param obj the object to compare with. * @return &#123;@code true&#125; if the objects are the same; * &#123;@code false&#125; otherwise. */public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 另外，除了Integer，向Long、Double等包装类，都有缓存区的操作，所以在使用两个包装类进行相等判断时需要注意，最好使用equals方法，引用类判断是否相等就应该使用equals方法，然后重写equals实现我们想要的相等规则。使用包装类型和基本类型做判断则不需要，会自动拆箱。","categories":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://blog.wangxt.online/tags/Integer/"},{"name":"IntegerCache","slug":"IntegerCache","permalink":"http://blog.wangxt.online/tags/IntegerCache/"}]},{"title":"给前端返回long类型造成精度损失","slug":"给前端返回long类型造成精度损失","date":"2022-12-04T06:38:00.000Z","updated":"2022-12-04T06:55:57.489Z","comments":true,"path":"2022/12/04/给前端返回long类型造成精度损失/","link":"","permalink":"http://blog.wangxt.online/2022/12/04/%E7%BB%99%E5%89%8D%E7%AB%AF%E8%BF%94%E5%9B%9Elong%E7%B1%BB%E5%9E%8B%E9%80%A0%E6%88%90%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1/","excerpt":"今天同事遇到一个问题，后端给前端返回一个long类型的参数列表，前端使用","text":"今天同事遇到一个问题，后端给前端返回一个long类型的参数列表，前端使用 原因JS的基础类型Number，遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。如图 意义 1位用来表示符号位 11位用来表示指数 52位表示尾数 浮点数，比如 1`0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）``0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）` 此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。 大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。 大于 9007199254740992 的可能会丢失精度 解决办法1、使用ToStringSerializer的注解，让系统序列化时，保留相关精度 123456@JsonSerialize(using=ToStringSerializer.class)private Long createdBy;FastJson 注解@JSONField(serializeUsing= ToStringSerializer.class) 上述方法需要在每个对象都配上该注解，此方法过于繁锁。 2、使用全局配置，将转换时实现自动ToStringSerializer序列化12345678910111213141516Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); /** * 序列换成json时,将所有的long变成string * 因为js中得数字类型不能包含所有的java long值 */ SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(simpleModule); jackson2HttpMessageConverter.setObjectMapper(objectMapper); converters.add(jackson2HttpMessageConverter); 项目中很多时候都会用到json，常用的有fastjson，Jackson等等这些，有时候为了统一，我们通常就会约定使用某一种。当然，有时候项目中也可能会统一约定使用了fastjson，然而Spring MVC中默认是使用了Jackson的 在Spring Boot中将Jackson替换为fastjson一般会有两种方式： 第一种： 12345678@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public HttpMessageConverters fastJsonHttpMessageConverter() &#123; return new HttpMessageConverters(new FastJsonHttpMessageConverter()); &#125;&#125; 第二种： 1234567891011121314@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); fastConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastConverter); &#125;&#125; 替换成fastjson之后，对于精度丢失问题，我们可以这么去做： 123456789101112131415161718@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); SerializeConfig serializeConfig = SerializeConfig.globalInstance; serializeConfig.put(BigInteger.class, ToStringSerializer.instance); serializeConfig.put(Long.class, ToStringSerializer.instance); serializeConfig.put(Long.TYPE, ToStringSerializer.instance); fastJsonConfig.setSerializeConfig(serializeConfig); fastConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastConverter); &#125;&#125; 总结吃一堑长一智，需要精度准确的比如浮点数或者长整形最好给前端返回string类型","categories":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"js类型","slug":"js类型","permalink":"http://blog.wangxt.online/tags/js%E7%B1%BB%E5%9E%8B/"}]},{"title":"Hexo文章Front-matter示例","slug":"hello-world","date":"2021-12-31T16:00:00.000Z","updated":"2021-12-31T16:00:01.000Z","comments":true,"path":"2022/01/01/hello-world/","link":"","permalink":"http://blog.wangxt.online/2022/01/01/hello-world/","excerpt":"这是摘要","text":"这是摘要 这是正文","categories":[],"tags":[]}],"categories":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://blog.wangxt.online/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"日常踩坑","slug":"日常踩坑","permalink":"http://blog.wangxt.online/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"},{"name":"思考总结","slug":"思考总结","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"},{"name":"Mysql","slug":"思考总结/Mysql","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/Mysql/"},{"name":"运维技巧","slug":"运维技巧","permalink":"http://blog.wangxt.online/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"},{"name":"小试牛刀","slug":"小试牛刀","permalink":"http://blog.wangxt.online/categories/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"},{"name":"生活","slug":"生活","permalink":"http://blog.wangxt.online/categories/%E7%94%9F%E6%B4%BB/"},{"name":"jdk源码","slug":"思考总结/jdk源码","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/jdk%E6%BA%90%E7%A0%81/"},{"name":"效率提升","slug":"效率提升","permalink":"http://blog.wangxt.online/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"},{"name":"数据库优化","slug":"思考总结/数据库优化","permalink":"http://blog.wangxt.online/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"日常开发","slug":"日常开发","permalink":"http://blog.wangxt.online/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"Arrays","slug":"Arrays","permalink":"http://blog.wangxt.online/tags/Arrays/"},{"name":"视图","slug":"视图","permalink":"http://blog.wangxt.online/tags/%E8%A7%86%E5%9B%BE/"},{"name":"踩坑","slug":"踩坑","permalink":"http://blog.wangxt.online/tags/%E8%B8%A9%E5%9D%91/"},{"name":"InnoDB索引","slug":"InnoDB索引","permalink":"http://blog.wangxt.online/tags/InnoDB%E7%B4%A2%E5%BC%95/"},{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wangxt.online/tags/Mysql/"},{"name":"数据结构","slug":"数据结构","permalink":"http://blog.wangxt.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"jdk按照","slug":"jdk按照","permalink":"http://blog.wangxt.online/tags/jdk%E6%8C%89%E7%85%A7/"},{"name":"centos","slug":"centos","permalink":"http://blog.wangxt.online/tags/centos/"},{"name":"Swagger","slug":"Swagger","permalink":"http://blog.wangxt.online/tags/Swagger/"},{"name":"springboot","slug":"springboot","permalink":"http://blog.wangxt.online/tags/springboot/"},{"name":"接口文档","slug":"接口文档","permalink":"http://blog.wangxt.online/tags/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"},{"name":"破解软件","slug":"破解软件","permalink":"http://blog.wangxt.online/tags/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.wangxt.online/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"源码","slug":"源码","permalink":"http://blog.wangxt.online/tags/%E6%BA%90%E7%A0%81/"},{"name":"AOP","slug":"AOP","permalink":"http://blog.wangxt.online/tags/AOP/"},{"name":"bat","slug":"bat","permalink":"http://blog.wangxt.online/tags/bat/"},{"name":"脚本","slug":"脚本","permalink":"http://blog.wangxt.online/tags/%E8%84%9A%E6%9C%AC/"},{"name":"便捷开发","slug":"便捷开发","permalink":"http://blog.wangxt.online/tags/%E4%BE%BF%E6%8D%B7%E5%BC%80%E5%8F%91/"},{"name":"shell","slug":"shell","permalink":"http://blog.wangxt.online/tags/shell/"},{"name":"git branch","slug":"git-branch","permalink":"http://blog.wangxt.online/tags/git-branch/"},{"name":"实用功能","slug":"实用功能","permalink":"http://blog.wangxt.online/tags/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"name":"Chrome插件","slug":"Chrome插件","permalink":"http://blog.wangxt.online/tags/Chrome%E6%8F%92%E4%BB%B6/"},{"name":"分库分表","slug":"分库分表","permalink":"http://blog.wangxt.online/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"http://blog.wangxt.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"SHH","slug":"SHH","permalink":"http://blog.wangxt.online/tags/SHH/"},{"name":"docker容器","slug":"docker容器","permalink":"http://blog.wangxt.online/tags/docker%E5%AE%B9%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.wangxt.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Integer","slug":"Integer","permalink":"http://blog.wangxt.online/tags/Integer/"},{"name":"IntegerCache","slug":"IntegerCache","permalink":"http://blog.wangxt.online/tags/IntegerCache/"},{"name":"js类型","slug":"js类型","permalink":"http://blog.wangxt.online/tags/js%E7%B1%BB%E5%9E%8B/"}]}